<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>JUNGLE SWING - So Easy Monkey Can Do It</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêµ</text></svg>">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #1a0a2e;
      overflow: hidden;
      font-family: 'Bangers', cursive;
      cursor: pointer;
      touch-action: none;
    }

    #game-canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    /* UI Overlay */
    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    /* Score display */
    #score-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    #score {
      font-size: 3.5rem;
      color: #ffd700;
      text-shadow:
        3px 3px 0 #ff6b00,
        6px 6px 0 rgba(0,0,0,0.3);
      letter-spacing: 4px;
    }

    #combo {
      font-size: 1.5rem;
      color: #00ffaa;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #combo.show {
      opacity: 1;
      transform: scale(1);
    }

    /* Banana counter */
    #banana-counter {
      position: absolute;
      top: 20px;
      right: 30px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .banana-icon {
      font-size: 2.5rem;
      filter: drop-shadow(3px 3px 2px rgba(0,0,0,0.4));
      animation: bananaWiggle 0.5s ease-in-out infinite;
    }

    @keyframes bananaWiggle {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }

    #banana-count {
      font-size: 2.5rem;
      color: #ffec00;
      text-shadow: 3px 3px 0 #cc9900, 5px 5px 0 rgba(0,0,0,0.3);
    }

    /* Start screen */
    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(180deg,
        rgba(26,10,46,0.9) 0%,
        rgba(10,40,30,0.85) 100%
      );
      pointer-events: auto;
      transition: opacity 0.5s, visibility 0.5s;
    }

    #start-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #game-title {
      font-size: 5rem;
      color: #00ff88;
      text-shadow:
        4px 4px 0 #008844,
        8px 8px 0 rgba(0,0,0,0.4);
      margin-bottom: 10px;
      animation: titlePulse 2s ease-in-out infinite;
    }

    @keyframes titlePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    #game-subtitle {
      font-size: 1.8rem;
      color: #ffcc00;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
      margin-bottom: 50px;
    }

    .start-btn {
      font-family: 'Bangers', cursive;
      font-size: 2.5rem;
      padding: 20px 60px;
      background: linear-gradient(180deg, #ff6b35 0%, #d63031 100%);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.4);
      box-shadow:
        0 8px 0 #8b1a1a,
        0 15px 30px rgba(0,0,0,0.4);
      transition: all 0.1s;
      letter-spacing: 3px;
    }

    .start-btn:hover {
      transform: translateY(-3px);
      box-shadow:
        0 11px 0 #8b1a1a,
        0 20px 40px rgba(0,0,0,0.5);
    }

    .start-btn:active {
      transform: translateY(4px);
      box-shadow:
        0 4px 0 #8b1a1a,
        0 8px 20px rgba(0,0,0,0.4);
    }

    #instructions {
      margin-top: 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 0.9rem;
      color: #88ffcc;
      text-align: center;
      line-height: 2;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
    }

    /* Game over screen */
    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(180deg,
        rgba(46,10,26,0.95) 0%,
        rgba(20,10,30,0.95) 100%
      );
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s, visibility 0.5s;
    }

    #game-over.show {
      opacity: 1;
      visibility: visible;
    }

    #game-over-title {
      font-size: 4rem;
      color: #ff4444;
      text-shadow:
        4px 4px 0 #880000,
        8px 8px 0 rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }

    #final-score-label {
      font-size: 1.5rem;
      color: #ffaa00;
      margin-bottom: 10px;
    }

    #final-score {
      font-size: 5rem;
      color: #ffd700;
      text-shadow:
        4px 4px 0 #ff8800,
        8px 8px 0 rgba(0,0,0,0.4);
      margin-bottom: 15px;
    }

    #high-score {
      font-size: 1.3rem;
      color: #00ffaa;
      margin-bottom: 40px;
    }

    /* Feedback text */
    #feedback {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      color: #00ff88;
      text-shadow:
        3px 3px 0 #008844,
        6px 6px 0 rgba(0,0,0,0.4);
      opacity: 0;
      pointer-events: none;
    }

    #feedback.perfect {
      color: #ffd700;
      text-shadow:
        3px 3px 0 #ff8800,
        6px 6px 0 rgba(0,0,0,0.4);
      animation: feedbackPop 0.6s ease-out forwards;
    }

    #feedback.good {
      color: #00ff88;
      animation: feedbackPop 0.6s ease-out forwards;
    }

    #feedback.miss {
      color: #ff4444;
      text-shadow:
        3px 3px 0 #880000,
        6px 6px 0 rgba(0,0,0,0.4);
      animation: feedbackPop 0.6s ease-out forwards;
    }

    @keyframes feedbackPop {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
    }

    /* Mobile touch hint */
    #touch-hint {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Press Start 2P', monospace;
      font-size: 1rem;
      color: rgba(255,255,255,0.6);
      animation: hintPulse 1.5s ease-in-out infinite;
    }

    @keyframes hintPulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }

    #touch-hint.hidden { display: none; }

    /* Back link */
    .back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      font-family: 'Press Start 2P', monospace;
      font-size: 0.7rem;
      color: rgba(255,255,255,0.6);
      text-decoration: none;
      pointer-events: auto;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: #00ff88;
    }

    /* Speed lines effect */
    #speed-lines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 50px,
        rgba(255,255,255,0.03) 50px,
        rgba(255,255,255,0.03) 51px
      );
      transition: opacity 0.3s;
    }

    #speed-lines.active {
      opacity: 1;
      animation: speedLinesMove 0.1s linear infinite;
    }

    @keyframes speedLinesMove {
      0% { background-position: 0 0; }
      100% { background-position: 51px 0; }
    }

    @media (max-width: 768px) {
      #game-title { font-size: 3rem; }
      #game-subtitle { font-size: 1.2rem; }
      .start-btn { font-size: 1.8rem; padding: 15px 40px; }
      #instructions { font-size: 0.7rem; padding: 0 20px; }
      #score { font-size: 2.5rem; }
      #banana-count { font-size: 1.8rem; }
      .banana-icon { font-size: 1.8rem; }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div id="ui">
    <a href="index.html" class="back-link">< HOME</a>

    <div id="score-display">
      <div id="score">0</div>
      <div id="combo"></div>
    </div>

    <div id="banana-counter">
      <span class="banana-icon">üçå</span>
      <span id="banana-count">0</span>
    </div>

    <div id="feedback"></div>
    <div id="speed-lines"></div>
    <div id="touch-hint">TAP TO SWING!</div>

    <div id="start-screen">
      <div id="game-title">JUNGLE SWING</div>
      <div id="game-subtitle">üêµ A Monkey Adventure üå¥</div>
      <button class="start-btn" onclick="game.start()">PLAY!</button>
      <div id="instructions">
        CLICK or TAP to grab vines<br>
        Collect bananas ‚Ä¢ Avoid falling<br>
        Time your swings perfectly!
      </div>
    </div>

    <div id="game-over">
      <div id="game-over-title">GAME OVER</div>
      <div id="final-score-label">SCORE</div>
      <div id="final-score">0</div>
      <div id="high-score">BEST: 0</div>
      <button class="start-btn" onclick="game.restart()">RETRY!</button>
    </div>
  </div>

  <script>
    // ==================== JUNGLE SWING 3D ====================
    // A modern retro-style 3D monkey swinging game

    class JungleSwing {
      constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.score = 0;
        this.bananas = 0;
        this.combo = 0;
        this.highScore = parseInt(localStorage.getItem('jungleSwingHighScore')) || 0;
        this.isPlaying = false;
        this.gameSpeed = 1;

        this.initThree();
        this.initLights();
        this.createEnvironment();
        this.createMonkey();
        this.createVines();
        this.setupControls();
        this.animate();
      }

      initThree() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a0a2e);
        this.scene.fog = new THREE.Fog(0x1a0a2e, 30, 80);

        // Camera
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 5, 18);
        this.camera.lookAt(0, 3, 0);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({
          canvas: this.canvas,
          antialias: true,
          powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Handle resize
        window.addEventListener('resize', () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      initLights() {
        // Ambient light
        const ambient = new THREE.AmbientLight(0x404060, 0.5);
        this.scene.add(ambient);

        // Main directional light (sun)
        const sun = new THREE.DirectionalLight(0xffffaa, 1);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 50;
        sun.shadow.camera.left = -20;
        sun.shadow.camera.right = 20;
        sun.shadow.camera.top = 20;
        sun.shadow.camera.bottom = -20;
        this.scene.add(sun);

        // Rim light for dramatic effect
        const rim = new THREE.DirectionalLight(0x00ffaa, 0.3);
        rim.position.set(-5, 5, -10);
        this.scene.add(rim);

        // Point light on monkey
        this.monkeyLight = new THREE.PointLight(0xffaa00, 0.5, 10);
        this.scene.add(this.monkeyLight);
      }

      createEnvironment() {
        // Ground
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        const groundMat = new THREE.MeshLambertMaterial({
          color: 0x1a3a20,
          side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -5;
        ground.receiveShadow = true;
        this.scene.add(ground);

        // Create low-poly trees
        this.trees = [];
        for (let i = 0; i < 40; i++) {
          const tree = this.createTree();
          const side = Math.random() > 0.5 ? 1 : -1;
          tree.position.set(
            side * (8 + Math.random() * 15),
            -5,
            -40 + Math.random() * 100
          );
          tree.rotation.y = Math.random() * Math.PI * 2;
          this.scene.add(tree);
          this.trees.push(tree);
        }

        // Floating particles (fireflies/pollen)
        this.particles = [];
        const particleGeo = new THREE.SphereGeometry(0.08, 4, 4);
        const particleMat = new THREE.MeshBasicMaterial({ color: 0xffff88 });

        for (let i = 0; i < 50; i++) {
          const particle = new THREE.Mesh(particleGeo, particleMat);
          particle.position.set(
            (Math.random() - 0.5) * 40,
            Math.random() * 15,
            (Math.random() - 0.5) * 60
          );
          particle.userData = {
            baseY: particle.position.y,
            speed: 0.5 + Math.random() * 1,
            offset: Math.random() * Math.PI * 2
          };
          this.scene.add(particle);
          this.particles.push(particle);
        }
      }

      createTree() {
        const tree = new THREE.Group();

        // Trunk (low-poly cylinder)
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 8, 6);
        const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 4;
        trunk.castShadow = true;
        tree.add(trunk);

        // Foliage layers (low-poly cones)
        const colors = [0x2d5a27, 0x3a7a35, 0x4a9a45];
        for (let i = 0; i < 3; i++) {
          const size = 3 - i * 0.7;
          const foliageGeo = new THREE.ConeGeometry(size, size * 1.5, 6);
          const foliageMat = new THREE.MeshLambertMaterial({ color: colors[i] });
          const foliage = new THREE.Mesh(foliageGeo, foliageMat);
          foliage.position.y = 6 + i * 2;
          foliage.castShadow = true;
          tree.add(foliage);
        }

        return tree;
      }

      createMonkey() {
        this.monkey = new THREE.Group();

        // Body
        const bodyGeo = new THREE.SphereGeometry(0.6, 8, 6);
        const bodyMat = new THREE.MeshLambertMaterial({ color: 0xd4712a });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.scale.y = 1.2;
        body.castShadow = true;
        this.monkey.add(body);

        // Head
        const headGeo = new THREE.SphereGeometry(0.5, 8, 6);
        const headMat = new THREE.MeshLambertMaterial({ color: 0xd4712a });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 0.9;
        head.castShadow = true;
        this.monkey.add(head);

        // Face
        const faceGeo = new THREE.SphereGeometry(0.35, 8, 6);
        const faceMat = new THREE.MeshLambertMaterial({ color: 0xf4c99a });
        const face = new THREE.Mesh(faceGeo, faceMat);
        face.position.set(0, 0.85, 0.3);
        face.scale.z = 0.7;
        this.monkey.add(face);

        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.1, 6, 6);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
        const eyeWhiteGeo = new THREE.SphereGeometry(0.14, 6, 6);
        const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

        [-0.15, 0.15].forEach(x => {
          const eyeWhite = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
          eyeWhite.position.set(x, 1, 0.4);
          this.monkey.add(eyeWhite);

          const eye = new THREE.Mesh(eyeGeo, eyeMat);
          eye.position.set(x, 1, 0.5);
          this.monkey.add(eye);
        });

        // Ears
        const earGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const earMat = new THREE.MeshLambertMaterial({ color: 0xd4712a });
        [-0.5, 0.5].forEach(x => {
          const ear = new THREE.Mesh(earGeo, earMat);
          ear.position.set(x, 1, 0);
          this.monkey.add(ear);
        });

        // Arms
        this.leftArm = this.createArm();
        this.leftArm.position.set(-0.5, 0.3, 0);
        this.monkey.add(this.leftArm);

        this.rightArm = this.createArm();
        this.rightArm.position.set(0.5, 0.3, 0);
        this.monkey.add(this.rightArm);

        // Tail
        const tailCurve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, -0.3, -0.3),
          new THREE.Vector3(0, -0.8, -0.6),
          new THREE.Vector3(0.3, -1.2, -0.4),
          new THREE.Vector3(0.5, -1, 0)
        ]);
        const tailGeo = new THREE.TubeGeometry(tailCurve, 12, 0.08, 6, false);
        const tailMat = new THREE.MeshLambertMaterial({ color: 0xd4712a });
        const tail = new THREE.Mesh(tailGeo, tailMat);
        tail.castShadow = true;
        this.monkey.add(tail);

        // Position monkey
        this.monkey.position.set(0, 5, 0);
        this.scene.add(this.monkey);

        // Physics state
        this.monkeyState = {
          swinging: false,
          falling: false,
          velocity: new THREE.Vector3(),
          currentVine: null,
          swingAngle: 0,
          swingSpeed: 0
        };
      }

      createArm() {
        const arm = new THREE.Group();
        const armGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.8, 6);
        const armMat = new THREE.MeshLambertMaterial({ color: 0xd4712a });
        const armMesh = new THREE.Mesh(armGeo, armMat);
        armMesh.position.y = -0.4;
        armMesh.castShadow = true;
        arm.add(armMesh);

        // Hand
        const handGeo = new THREE.SphereGeometry(0.12, 6, 6);
        const handMat = new THREE.MeshLambertMaterial({ color: 0xf4c99a });
        const hand = new THREE.Mesh(handGeo, handMat);
        hand.position.y = -0.8;
        arm.add(hand);

        return arm;
      }

      createVines() {
        this.vines = [];
        this.bananaObjects = [];

        // Create initial vines
        for (let i = 0; i < 8; i++) {
          this.addVine(i * 5 - 5);
        }

        this.currentVineIndex = 1;
        this.attachToVine(this.vines[this.currentVineIndex]);
      }

      addVine(z) {
        const vine = new THREE.Group();
        vine.userData = {
          grabbed: false,
          z: z,
          swingOffset: Math.random() * Math.PI * 2,
          hasBanana: Math.random() > 0.4
        };

        // Vine rope
        const ropeGeo = new THREE.CylinderGeometry(0.05, 0.05, 8, 6);
        const ropeMat = new THREE.MeshLambertMaterial({ color: 0x3a7a35 });
        const rope = new THREE.Mesh(ropeGeo, ropeMat);
        rope.position.y = 4;
        vine.add(rope);

        // Leaves on vine
        const leafGeo = new THREE.ConeGeometry(0.3, 0.6, 4);
        const leafMat = new THREE.MeshLambertMaterial({ color: 0x4a9a45 });
        for (let i = 0; i < 4; i++) {
          const leaf = new THREE.Mesh(leafGeo, leafMat);
          leaf.position.y = 2 + i * 1.5;
          leaf.position.x = (i % 2 === 0 ? 0.2 : -0.2);
          leaf.rotation.z = (i % 2 === 0 ? -0.5 : 0.5);
          vine.add(leaf);
        }

        // Grab point (invisible)
        vine.userData.grabPoint = new THREE.Vector3(0, 0, 0);

        // Position
        const xOffset = (Math.random() - 0.5) * 4;
        vine.position.set(xOffset, 8, z);

        // Banana
        if (vine.userData.hasBanana) {
          const banana = this.createBanana();
          banana.position.set(xOffset + (Math.random() - 0.5) * 2, 4 + Math.random() * 3, z);
          banana.userData.collected = false;
          banana.userData.vineZ = z;
          this.scene.add(banana);
          this.bananaObjects.push(banana);
        }

        this.scene.add(vine);
        this.vines.push(vine);

        return vine;
      }

      createBanana() {
        const banana = new THREE.Group();

        // Banana bunch
        const bananaGeo = new THREE.TorusGeometry(0.25, 0.1, 6, 8, Math.PI);
        const bananaMat = new THREE.MeshLambertMaterial({ color: 0xffe135 });

        for (let i = 0; i < 3; i++) {
          const b = new THREE.Mesh(bananaGeo, bananaMat);
          b.rotation.z = Math.PI / 2 + (i - 1) * 0.3;
          b.position.x = (i - 1) * 0.15;
          banana.add(b);
        }

        // Glow
        const glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
        const glowMat = new THREE.MeshBasicMaterial({
          color: 0xffff00,
          transparent: true,
          opacity: 0.2
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        banana.add(glow);

        banana.userData.baseY = 0;
        banana.userData.rotSpeed = 0.02 + Math.random() * 0.02;

        return banana;
      }

      setupControls() {
        const handleInput = () => {
          if (!this.isPlaying) return;
          this.swing();
        };

        document.addEventListener('click', handleInput);
        document.addEventListener('touchstart', (e) => {
          e.preventDefault();
          handleInput();
        }, { passive: false });

        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space') {
            e.preventDefault();
            if (this.isPlaying) {
              this.swing();
            } else if (!document.getElementById('start-screen').classList.contains('hidden')) {
              this.start();
            } else {
              this.restart();
            }
          }
        });
      }

      swing() {
        const state = this.monkeyState;
        if (state.falling) return;

        // Release from current vine
        if (state.swinging) {
          state.swinging = false;

          // Calculate release velocity based on swing
          const speed = Math.abs(state.swingSpeed) * 0.5 + this.gameSpeed * 3;
          state.velocity.set(
            state.swingSpeed * 0.5,
            Math.abs(state.swingSpeed) * 0.3 + 2,
            -speed
          );

          // Remove touch hint after first swing
          document.getElementById('touch-hint').classList.add('hidden');
        }

        // Try to grab next vine
        this.tryGrabVine();
      }

      tryGrabVine() {
        const state = this.monkeyState;
        const monkeyPos = this.monkey.position;

        // Find closest ungrabbed vine in front
        let closestVine = null;
        let closestDist = Infinity;

        for (const vine of this.vines) {
          if (vine.userData.grabbed) continue;

          const vinePos = vine.position;
          const dist = Math.sqrt(
            Math.pow(monkeyPos.x - vinePos.x, 2) +
            Math.pow(monkeyPos.z - vinePos.z, 2)
          );

          if (vinePos.z < monkeyPos.z && dist < closestDist && dist < 6) {
            closestDist = dist;
            closestVine = vine;
          }
        }

        if (closestVine) {
          this.attachToVine(closestVine);

          // Score based on timing
          if (closestDist < 1.5) {
            this.addScore(100);
            this.showFeedback('PERFECT!', 'perfect');
            this.combo++;
          } else if (closestDist < 3) {
            this.addScore(50);
            this.showFeedback('GOOD!', 'good');
            this.combo++;
          } else {
            this.addScore(20);
            this.combo = 0;
          }

          // Update combo display
          this.updateCombo();
        }
      }

      attachToVine(vine) {
        const state = this.monkeyState;

        vine.userData.grabbed = true;
        state.swinging = true;
        state.falling = false;
        state.currentVine = vine;
        state.swingAngle = 0;
        state.swingSpeed = 2;
        state.velocity.set(0, 0, 0);

        // Arms up animation
        this.leftArm.rotation.z = Math.PI;
        this.rightArm.rotation.z = -Math.PI;
      }

      showFeedback(text, type) {
        const feedback = document.getElementById('feedback');
        feedback.textContent = text;
        feedback.className = type;

        // Reset animation
        void feedback.offsetWidth;
        feedback.className = type;
      }

      updateCombo() {
        const comboEl = document.getElementById('combo');
        if (this.combo > 1) {
          comboEl.textContent = `${this.combo}x COMBO!`;
          comboEl.classList.add('show');
        } else {
          comboEl.classList.remove('show');
        }
      }

      addScore(points) {
        const multiplier = Math.min(this.combo + 1, 5);
        this.score += points * multiplier;
        document.getElementById('score').textContent = this.score;
      }

      collectBanana(banana) {
        if (banana.userData.collected) return;

        banana.userData.collected = true;
        this.bananas++;
        document.getElementById('banana-count').textContent = this.bananas;
        this.addScore(25);

        // Collect animation
        const targetY = banana.position.y + 3;
        const startY = banana.position.y;
        const startScale = 1;
        let t = 0;

        const animateCollect = () => {
          t += 0.1;
          if (t >= 1) {
            this.scene.remove(banana);
            return;
          }

          banana.position.y = startY + (targetY - startY) * t;
          const scale = startScale * (1 - t);
          banana.scale.set(scale, scale, scale);
          banana.rotation.y += 0.3;

          requestAnimationFrame(animateCollect);
        };

        animateCollect();
      }

      update(deltaTime) {
        if (!this.isPlaying) return;

        const state = this.monkeyState;

        // Update game speed over time
        this.gameSpeed = Math.min(1 + this.score / 5000, 2.5);

        // Speed lines effect at high speed
        const speedLines = document.getElementById('speed-lines');
        if (this.gameSpeed > 1.5) {
          speedLines.classList.add('active');
        } else {
          speedLines.classList.remove('active');
        }

        if (state.swinging && state.currentVine) {
          // Swing physics
          state.swingAngle += state.swingSpeed * deltaTime;
          state.swingSpeed = Math.sin(state.swingAngle) * 3;

          const vine = state.currentVine;
          const swingRadius = 3;
          const swingX = Math.sin(state.swingAngle * 0.5) * swingRadius;
          const swingY = -Math.abs(Math.cos(state.swingAngle * 0.5)) * swingRadius * 0.3;

          this.monkey.position.x = vine.position.x + swingX;
          this.monkey.position.y = 5 + swingY;
          this.monkey.position.z = vine.position.z + 1;

          // Monkey rotation while swinging
          this.monkey.rotation.z = state.swingAngle * 0.2;

          // Auto-release if swinging too long
          if (Math.abs(state.swingAngle) > Math.PI * 3) {
            this.swing();
          }
        } else {
          // Flying/falling physics
          state.velocity.y -= 15 * deltaTime; // Gravity
          state.velocity.z -= this.gameSpeed * 0.5 * deltaTime; // Forward momentum

          this.monkey.position.add(state.velocity.clone().multiplyScalar(deltaTime));

          // Rotation while flying
          this.monkey.rotation.z = Math.sin(Date.now() * 0.01) * 0.2;
          this.monkey.rotation.x = state.velocity.y * 0.05;

          // Arms down while flying
          this.leftArm.rotation.z = 0.3;
          this.rightArm.rotation.z = -0.3;

          // Check if fallen
          if (this.monkey.position.y < -3) {
            this.gameOver();
            return;
          }

          // Auto-grab if close to vine
          if (!state.swinging && state.velocity.y < 0) {
            this.tryGrabVine();
          }
        }

        // Update monkey light
        this.monkeyLight.position.copy(this.monkey.position);
        this.monkeyLight.position.y += 2;

        // Camera follow
        const targetCamZ = this.monkey.position.z + 18;
        const targetCamX = this.monkey.position.x * 0.3;
        this.camera.position.z += (targetCamZ - this.camera.position.z) * 0.05;
        this.camera.position.x += (targetCamX - this.camera.position.x) * 0.1;
        this.camera.lookAt(
          this.monkey.position.x * 0.5,
          4,
          this.monkey.position.z - 5
        );

        // Update vines (swing animation)
        this.vines.forEach(vine => {
          if (!vine.userData.grabbed) {
            vine.rotation.z = Math.sin(Date.now() * 0.002 + vine.userData.swingOffset) * 0.1;
          }

          // Remove vines that are too far behind
          if (vine.position.z > this.monkey.position.z + 20) {
            this.scene.remove(vine);
            this.vines = this.vines.filter(v => v !== vine);
          }
        });

        // Add new vines ahead
        const furthestZ = Math.min(...this.vines.map(v => v.position.z));
        if (this.monkey.position.z - furthestZ < 30) {
          this.addVine(furthestZ - 5);
        }

        // Update bananas
        this.bananaObjects.forEach((banana, index) => {
          if (banana.userData.collected) return;

          // Rotate and bob
          banana.rotation.y += banana.userData.rotSpeed;
          banana.position.y = banana.userData.baseY || banana.position.y;
          banana.position.y += Math.sin(Date.now() * 0.003 + index) * 0.02;

          // Check collection
          const dist = this.monkey.position.distanceTo(banana.position);
          if (dist < 1.5) {
            this.collectBanana(banana);
          }

          // Remove if too far behind
          if (banana.position.z > this.monkey.position.z + 15) {
            this.scene.remove(banana);
            this.bananaObjects = this.bananaObjects.filter(b => b !== banana);
          }
        });

        // Update particles
        this.particles.forEach(particle => {
          particle.position.y = particle.userData.baseY +
            Math.sin(Date.now() * 0.001 * particle.userData.speed + particle.userData.offset) * 0.5;
          particle.position.x += Math.sin(Date.now() * 0.0005 + particle.userData.offset) * 0.01;
        });

        // Move trees that are too far behind to front
        this.trees.forEach(tree => {
          if (tree.position.z > this.monkey.position.z + 30) {
            tree.position.z -= 100;
            tree.position.x = (Math.random() > 0.5 ? 1 : -1) * (8 + Math.random() * 15);
          }
        });
      }

      gameOver() {
        this.isPlaying = false;
        this.monkeyState.falling = true;

        // Update high score
        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('jungleSwingHighScore', this.highScore);
        }

        // Show game over screen
        document.getElementById('final-score').textContent = this.score;
        document.getElementById('high-score').textContent = `BEST: ${this.highScore}`;
        document.getElementById('game-over').classList.add('show');
        document.getElementById('speed-lines').classList.remove('active');

        this.showFeedback('OOPS!', 'miss');
      }

      start() {
        document.getElementById('start-screen').classList.add('hidden');
        this.isPlaying = true;
        this.score = 0;
        this.bananas = 0;
        this.combo = 0;
        this.gameSpeed = 1;

        document.getElementById('score').textContent = '0';
        document.getElementById('banana-count').textContent = '0';
        document.getElementById('combo').classList.remove('show');
      }

      restart() {
        document.getElementById('game-over').classList.remove('show');

        // Reset monkey position
        this.monkey.position.set(0, 5, 0);
        this.monkey.rotation.set(0, 0, 0);
        this.monkeyState = {
          swinging: false,
          falling: false,
          velocity: new THREE.Vector3(),
          currentVine: null,
          swingAngle: 0,
          swingSpeed: 0
        };

        // Clear and recreate vines
        this.vines.forEach(vine => this.scene.remove(vine));
        this.vines = [];
        this.bananaObjects.forEach(banana => this.scene.remove(banana));
        this.bananaObjects = [];

        for (let i = 0; i < 8; i++) {
          this.addVine(i * 5 - 5);
        }

        this.currentVineIndex = 1;
        this.attachToVine(this.vines[this.currentVineIndex]);

        // Reset camera
        this.camera.position.set(0, 5, 18);

        // Start game
        this.score = 0;
        this.bananas = 0;
        this.combo = 0;
        this.gameSpeed = 1;

        document.getElementById('score').textContent = '0';
        document.getElementById('banana-count').textContent = '0';
        document.getElementById('combo').classList.remove('show');
        document.getElementById('touch-hint').classList.remove('hidden');

        this.isPlaying = true;
      }

      animate() {
        let lastTime = performance.now();

        const loop = (currentTime) => {
          requestAnimationFrame(loop);

          const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
          lastTime = currentTime;

          this.update(deltaTime);
          this.renderer.render(this.scene, this.camera);
        };

        requestAnimationFrame(loop);
      }
    }

    // Initialize game
    const game = new JungleSwing();
  </script>
</body>
</html>

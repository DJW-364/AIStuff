<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Swinger Monkey - So Easy Monkey Can Do It</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêµ</text></svg>">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Press+Start+2P&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #1a0a2e;
      overflow: hidden;
      font-family: 'Bangers', cursive;
      cursor: pointer;
      touch-action: none;
    }

    #game-canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    #score-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #score {
      font-size: 3.5rem;
      color: #ffd700;
      text-shadow: 3px 3px 0 #ff6b00, 6px 6px 0 rgba(0,0,0,0.3);
      letter-spacing: 4px;
    }

    .banana-icon {
      font-size: 2.5rem;
      filter: drop-shadow(3px 3px 2px rgba(0,0,0,0.4));
      animation: bananaWiggle 0.5s ease-in-out infinite;
      margin-right: 10px;
    }

    @keyframes bananaWiggle {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }

    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(180deg, rgba(26,10,46,0.9) 0%, rgba(10,40,30,0.85) 100%);
      pointer-events: auto;
      transition: opacity 0.5s, visibility 0.5s;
    }

    #start-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

    #game-title {
      font-size: 5rem;
      color: #00ff88;
      text-shadow: 4px 4px 0 #008844, 8px 8px 0 rgba(0,0,0,0.4);
      margin-bottom: 10px;
      animation: titlePulse 2s ease-in-out infinite;
    }

    @keyframes titlePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    #game-subtitle {
      font-size: 1.8rem;
      color: #ffcc00;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
      margin-bottom: 50px;
    }

    .start-btn {
      font-family: 'Bangers', cursive;
      font-size: 2.5rem;
      padding: 20px 60px;
      background: linear-gradient(180deg, #ff6b35 0%, #d63031 100%);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.4);
      box-shadow: 0 8px 0 #8b1a1a, 0 15px 30px rgba(0,0,0,0.4);
      transition: all 0.1s;
      letter-spacing: 3px;
    }

    .start-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 11px 0 #8b1a1a, 0 20px 40px rgba(0,0,0,0.5);
    }

    .start-btn:active {
      transform: translateY(4px);
      box-shadow: 0 4px 0 #8b1a1a, 0 8px 20px rgba(0,0,0,0.4);
    }

    #instructions {
      margin-top: 40px;
      font-family: 'Press Start 2P', monospace;
      font-size: 0.9rem;
      color: #88ffcc;
      text-align: center;
      line-height: 2;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
    }

    #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(180deg, rgba(46,10,26,0.95) 0%, rgba(20,10,30,0.95) 100%);
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s, visibility 0.5s;
    }

    #game-over.show { opacity: 1; visibility: visible; }

    #game-over-title {
      font-size: 4rem;
      color: #ff4444;
      text-shadow: 4px 4px 0 #880000, 8px 8px 0 rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }

    #final-score-label { font-size: 1.5rem; color: #ffaa00; margin-bottom: 10px; }

    #final-score {
      font-size: 5rem;
      color: #ffd700;
      text-shadow: 4px 4px 0 #ff8800, 8px 8px 0 rgba(0,0,0,0.4);
      margin-bottom: 15px;
    }

    #high-score { font-size: 1.3rem; color: #00ffaa; margin-bottom: 40px; }

    #feedback {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      color: #00ff88;
      text-shadow: 3px 3px 0 #008844, 6px 6px 0 rgba(0,0,0,0.4);
      opacity: 0;
      pointer-events: none;
    }

    #feedback.perfect { color: #ffd700; text-shadow: 3px 3px 0 #ff8800, 6px 6px 0 rgba(0,0,0,0.4); animation: feedbackPop 0.6s ease-out forwards; }
    #feedback.good { color: #00ff88; animation: feedbackPop 0.6s ease-out forwards; }
    #feedback.miss { color: #ff4444; text-shadow: 3px 3px 0 #880000, 6px 6px 0 rgba(0,0,0,0.4); animation: feedbackPop 0.6s ease-out forwards; }

    @keyframes feedbackPop {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
    }

    #touch-hint {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Press Start 2P', monospace;
      font-size: 1rem;
      color: rgba(255,255,255,0.6);
      animation: hintPulse 1.5s ease-in-out infinite;
    }

    @keyframes hintPulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.8; } }
    #touch-hint.hidden { display: none; }

    .back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      font-family: 'Press Start 2P', monospace;
      font-size: 0.7rem;
      color: rgba(255,255,255,0.6);
      text-decoration: none;
      pointer-events: auto;
      transition: color 0.2s;
    }

    .back-link:hover { color: #00ff88; }

    @media (max-width: 768px) {
      #game-title { font-size: 3rem; }
      #game-subtitle { font-size: 1.2rem; }
      .start-btn { font-size: 1.8rem; padding: 15px 40px; }
      #instructions { font-size: 0.7rem; padding: 0 20px; }
      #score { font-size: 2.5rem; }
      #banana-count { font-size: 1.8rem; }
      .banana-icon { font-size: 1.8rem; }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div id="ui">
    <a href="index.html" class="back-link">< HOME</a>

    <div id="score-display">
      <span class="banana-icon">üçå</span>
      <div id="score">0</div>
    </div>

    <div id="feedback"></div>
    <div id="touch-hint">TAP TO SWING!</div>

    <div id="start-screen">
      <div id="game-title">SWINGER MONKEY</div>
      <div id="game-subtitle">üêµ A Monkey Adventure üå¥</div>
      <button class="start-btn" onclick="game.start()">PLAY!</button>
      <div id="instructions">
        TAP or CLICK to jump to next vine<br>
        Time it right for bonus points!<br>
        Collect bananas ‚Ä¢ Don't fall!
      </div>
    </div>

    <div id="game-over">
      <div id="game-over-title">GAME OVER</div>
      <div id="final-score-label">üçå BANANAS üçå</div>
      <div id="final-score">0</div>
      <div id="high-score">BEST: 0</div>
      <button class="start-btn" onclick="game.restart()">RETRY!</button>
    </div>
  </div>

  <script>
    // ==================== JUNGLE SWING 3D - IMPROVED ====================

    class JungleSwing {
      constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.score = 0;
        this.bananas = 0;
        this.highScore = parseInt(localStorage.getItem('swingerMonkeyHighScore')) || 0;
        this.isPlaying = false;
        this.gameSpeed = 1;

        this.initThree();
        this.initLights();
        this.createEnvironment();
        this.createMonkey();
        this.createVineSystem();
        this.setupControls();
        this.animate();
      }

      initThree() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a0a2e);
        this.scene.fog = new THREE.Fog(0x1a0a2e, 40, 100);

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 8, 25);
        this.camera.lookAt(0, 5, 0);

        this.renderer = new THREE.WebGLRenderer({
          canvas: this.canvas,
          antialias: true,
          powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        window.addEventListener('resize', () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      initLights() {
        const ambient = new THREE.AmbientLight(0x404080, 0.6);
        this.scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffcc, 1.2);
        sun.position.set(15, 30, 20);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 100;
        sun.shadow.camera.left = -30;
        sun.shadow.camera.right = 30;
        sun.shadow.camera.top = 30;
        sun.shadow.camera.bottom = -30;
        this.scene.add(sun);

        const rim = new THREE.DirectionalLight(0x00ffaa, 0.4);
        rim.position.set(-10, 10, -20);
        this.scene.add(rim);

        this.monkeyLight = new THREE.PointLight(0xffaa00, 0.8, 15);
        this.scene.add(this.monkeyLight);
      }

      createEnvironment() {
        // Ground with texture variation
        const groundGeo = new THREE.PlaneGeometry(300, 300, 20, 20);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0x2d5a1a });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -10;
        ground.receiveShadow = true;
        this.scene.add(ground);

        // Grass tufts on the ground
        this.groundDetails = [];
        const grassColors = [0x3a7a2a, 0x4a8a3a, 0x2a6a1a];
        for (let i = 0; i < 100; i++) {
          const grass = new THREE.Group();
          const bladeCount = 3 + Math.floor(Math.random() * 4);
          for (let j = 0; j < bladeCount; j++) {
            const bladeGeo = new THREE.ConeGeometry(0.15, 1.5 + Math.random(), 4);
            const bladeMat = new THREE.MeshLambertMaterial({
              color: grassColors[Math.floor(Math.random() * grassColors.length)]
            });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.set((Math.random() - 0.5) * 0.5, 0.5, (Math.random() - 0.5) * 0.5);
            blade.rotation.set((Math.random() - 0.5) * 0.3, 0, (Math.random() - 0.5) * 0.3);
            grass.add(blade);
          }
          grass.position.set(
            (Math.random() - 0.5) * 60,
            -10,
            (Math.random() - 0.5) * 150
          );
          this.scene.add(grass);
          this.groundDetails.push(grass);
        }

        // Bushes
        const bushColors = [0x2d6a30, 0x3a8a40, 0x1a5a20];
        for (let i = 0; i < 40; i++) {
          const bush = new THREE.Group();
          const sphereCount = 2 + Math.floor(Math.random() * 3);
          for (let j = 0; j < sphereCount; j++) {
            const bushGeo = new THREE.SphereGeometry(0.8 + Math.random() * 0.6, 8, 8);
            const bushMat = new THREE.MeshLambertMaterial({
              color: bushColors[Math.floor(Math.random() * bushColors.length)]
            });
            const sphere = new THREE.Mesh(bushGeo, bushMat);
            sphere.position.set((Math.random() - 0.5) * 1.5, Math.random() * 0.5, (Math.random() - 0.5) * 1.5);
            sphere.scale.y = 0.7;
            bush.add(sphere);
          }
          const side = Math.random() > 0.5 ? 1 : -1;
          bush.position.set(
            side * (8 + Math.random() * 25),
            -9.5,
            -50 + Math.random() * 150
          );
          this.scene.add(bush);
          this.groundDetails.push(bush);
        }

        // Rocks
        for (let i = 0; i < 25; i++) {
          const rockGeo = new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.8, 0);
          const rockMat = new THREE.MeshLambertMaterial({ color: 0x555555 + Math.random() * 0x222222 });
          const rock = new THREE.Mesh(rockGeo, rockMat);
          rock.position.set(
            (Math.random() - 0.5) * 50,
            -9.5,
            (Math.random() - 0.5) * 150
          );
          rock.rotation.set(Math.random(), Math.random(), Math.random());
          rock.scale.y = 0.6;
          this.scene.add(rock);
          this.groundDetails.push(rock);
        }

        // Trees - closer to action with layers
        this.trees = [];
        // Foreground trees (closer, sides of play area)
        for (let i = 0; i < 30; i++) {
          const tree = this.createTree();
          const side = Math.random() > 0.5 ? 1 : -1;
          tree.position.set(
            side * (10 + Math.random() * 8),
            -10,
            -50 + Math.random() * 150
          );
          tree.rotation.y = Math.random() * Math.PI * 2;
          const scale = 0.9 + Math.random() * 0.5;
          tree.scale.set(scale, scale, scale);
          this.scene.add(tree);
          this.trees.push(tree);
        }
        // Background trees (further, smaller)
        for (let i = 0; i < 40; i++) {
          const tree = this.createTree();
          const side = Math.random() > 0.5 ? 1 : -1;
          tree.position.set(
            side * (25 + Math.random() * 20),
            -10,
            -50 + Math.random() * 150
          );
          tree.rotation.y = Math.random() * Math.PI * 2;
          const scale = 0.5 + Math.random() * 0.4;
          tree.scale.set(scale, scale, scale);
          this.scene.add(tree);
          this.trees.push(tree);
        }

        // Jungle canopy at top of screen
        this.canopy = [];
        const canopyLeafGeo = new THREE.SphereGeometry(3, 8, 8);
        const canopyColors = [0x1a5a20, 0x2d6a30, 0x3a7a40, 0x1a4a15];
        for (let i = 0; i < 60; i++) {
          const leafMat = new THREE.MeshLambertMaterial({
            color: canopyColors[Math.floor(Math.random() * canopyColors.length)],
            transparent: true,
            opacity: 0.9
          });
          const leaf = new THREE.Mesh(canopyLeafGeo, leafMat);
          leaf.position.set(
            (Math.random() - 0.5) * 80,
            18 + Math.random() * 10,
            -60 + Math.random() * 100
          );
          leaf.scale.set(1 + Math.random(), 0.5 + Math.random() * 0.3, 1 + Math.random());
          this.scene.add(leaf);
          this.canopy.push(leaf);
        }

        // Hanging vines from canopy (decorative)
        for (let i = 0; i < 30; i++) {
          const hangingVine = new THREE.Group();
          const vineLength = 5 + Math.random() * 8;
          const vineGeo = new THREE.CylinderGeometry(0.05, 0.03, vineLength, 6);
          const vineMat = new THREE.MeshLambertMaterial({ color: 0x2d5a1a });
          const vine = new THREE.Mesh(vineGeo, vineMat);
          vine.position.y = -vineLength / 2;
          hangingVine.add(vine);

          // Small leaves on hanging vine
          for (let j = 0; j < 3; j++) {
            const leafGeo = new THREE.SphereGeometry(0.2, 4, 4);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x3a8a30 });
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.position.set(0.15, -1 - j * 1.5, 0);
            leaf.scale.set(1, 0.5, 0.6);
            hangingVine.add(leaf);
          }

          const side = Math.random() > 0.5 ? 1 : -1;
          hangingVine.position.set(
            side * (12 + Math.random() * 15),
            22 + Math.random() * 5,
            -50 + Math.random() * 120
          );
          this.scene.add(hangingVine);
          this.canopy.push(hangingVine);
        }

        // Fireflies (only in air, glowing)
        this.particles = [];
        for (let i = 0; i < 30; i++) {
          const fireflyGeo = new THREE.SphereGeometry(0.08, 6, 6);
          const fireflyMat = new THREE.MeshBasicMaterial({
            color: 0xffff88,
            transparent: true,
            opacity: 0.8
          });
          const firefly = new THREE.Mesh(fireflyGeo, fireflyMat);

          // Add glow
          const glowGeo = new THREE.SphereGeometry(0.2, 6, 6);
          const glowMat = new THREE.MeshBasicMaterial({
            color: 0xffff44,
            transparent: true,
            opacity: 0.3
          });
          const glow = new THREE.Mesh(glowGeo, glowMat);
          firefly.add(glow);

          firefly.position.set(
            (Math.random() - 0.5) * 40,
            5 + Math.random() * 15, // Only in the air
            (Math.random() - 0.5) * 60
          );
          firefly.userData = {
            baseY: firefly.position.y,
            baseX: firefly.position.x,
            speed: 0.3 + Math.random() * 0.5,
            offset: Math.random() * Math.PI * 2,
            glowSpeed: 2 + Math.random() * 2
          };
          this.scene.add(firefly);
          this.particles.push(firefly);
        }

        // Butterflies
        this.butterflies = [];
        const butterflyColors = [0xff6b9d, 0x6bb5ff, 0xffdb4d, 0xff8c42];
        for (let i = 0; i < 15; i++) {
          const butterfly = new THREE.Group();
          const wingGeo = new THREE.CircleGeometry(0.3, 6);
          const wingColor = butterflyColors[Math.floor(Math.random() * butterflyColors.length)];
          const wingMat = new THREE.MeshBasicMaterial({
            color: wingColor,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
          });

          const leftWing = new THREE.Mesh(wingGeo, wingMat);
          leftWing.position.x = -0.15;
          leftWing.rotation.y = 0.5;
          butterfly.add(leftWing);

          const rightWing = new THREE.Mesh(wingGeo, wingMat);
          rightWing.position.x = 0.15;
          rightWing.rotation.y = -0.5;
          butterfly.add(rightWing);

          // Body
          const bodyGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 4);
          const bodyMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          body.rotation.z = Math.PI / 2;
          butterfly.add(body);

          butterfly.position.set(
            (Math.random() - 0.5) * 30,
            3 + Math.random() * 12,
            (Math.random() - 0.5) * 50
          );
          butterfly.userData = {
            basePos: butterfly.position.clone(),
            speed: 0.5 + Math.random() * 0.5,
            offset: Math.random() * Math.PI * 2,
            wingSpeed: 8 + Math.random() * 4,
            leftWing: leftWing,
            rightWing: rightWing
          };
          this.scene.add(butterfly);
          this.butterflies.push(butterfly);
        }

        // Distant mountain/hill silhouettes for depth
        const hillGeo = new THREE.SphereGeometry(30, 16, 16);
        const hillMat = new THREE.MeshBasicMaterial({ color: 0x1a3a25 });
        for (let i = 0; i < 5; i++) {
          const hill = new THREE.Mesh(hillGeo, hillMat);
          hill.position.set(
            -80 + i * 40,
            -20,
            -80
          );
          hill.scale.set(1 + Math.random() * 0.5, 0.4 + Math.random() * 0.3, 1);
          this.scene.add(hill);
        }
      }

      createTree() {
        const tree = new THREE.Group();

        // Jungle palm tree trunk - taller and curved
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 18, 8);
        const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B5A2B });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 9;
        trunk.castShadow = true;
        tree.add(trunk);

        // Trunk rings/texture
        for (let i = 0; i < 8; i++) {
          const ringGeo = new THREE.TorusGeometry(0.35, 0.08, 6, 12);
          const ringMat = new THREE.MeshLambertMaterial({ color: 0x6B4423 });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.position.y = 2 + i * 2;
          ring.rotation.x = Math.PI / 2;
          tree.add(ring);
        }

        // Palm fronds (large tropical leaves)
        const frondMat = new THREE.MeshLambertMaterial({ color: 0x228B22, side: THREE.DoubleSide });
        const numFronds = 7;
        for (let i = 0; i < numFronds; i++) {
          const frond = new THREE.Group();

          // Create elongated leaf shape
          const leafGeo = new THREE.ConeGeometry(0.8, 6, 4);
          const leaf = new THREE.Mesh(leafGeo, frondMat);
          leaf.rotation.x = Math.PI / 2;
          leaf.position.z = 3;
          leaf.scale.set(1, 0.15, 1);
          frond.add(leaf);

          // Add smaller leaves along the frond
          for (let j = 0; j < 5; j++) {
            const smallLeaf = new THREE.Mesh(
              new THREE.ConeGeometry(0.4, 2, 3),
              new THREE.MeshLambertMaterial({ color: 0x2E8B2E })
            );
            smallLeaf.position.set(0.3, 0, 1 + j * 1);
            smallLeaf.rotation.set(0, 0, -0.5);
            frond.add(smallLeaf);

            const smallLeaf2 = smallLeaf.clone();
            smallLeaf2.position.x = -0.3;
            smallLeaf2.rotation.z = 0.5;
            frond.add(smallLeaf2);
          }

          frond.position.y = 18;
          frond.rotation.y = (i / numFronds) * Math.PI * 2;
          frond.rotation.x = 0.4 + Math.random() * 0.3; // Droop down
          tree.add(frond);
        }

        // Coconuts
        const coconutGeo = new THREE.SphereGeometry(0.4, 8, 8);
        const coconutMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        for (let i = 0; i < 3; i++) {
          const coconut = new THREE.Mesh(coconutGeo, coconutMat);
          coconut.position.set(
            Math.cos(i * 2) * 0.5,
            17,
            Math.sin(i * 2) * 0.5
          );
          tree.add(coconut);
        }

        return tree;
      }

      createMonkey() {
        this.monkey = new THREE.Group();

        // Body
        const bodyGeo = new THREE.SphereGeometry(0.7, 12, 10);
        const bodyMat = new THREE.MeshLambertMaterial({ color: 0xd4712a });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.scale.set(1, 1.3, 0.9);
        body.castShadow = true;
        this.monkey.add(body);

        // Head
        const headGeo = new THREE.SphereGeometry(0.55, 12, 10);
        const head = new THREE.Mesh(headGeo, bodyMat);
        head.position.y = 1.1;
        head.castShadow = true;
        this.monkey.add(head);

        // Face
        const faceGeo = new THREE.SphereGeometry(0.4, 10, 10);
        const faceMat = new THREE.MeshLambertMaterial({ color: 0xf4c99a });
        const face = new THREE.Mesh(faceGeo, faceMat);
        face.position.set(0, 1.05, 0.35);
        face.scale.set(1, 0.9, 0.6);
        this.monkey.add(face);

        // Eyes
        const eyeWhiteGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

        [-0.18, 0.18].forEach(x => {
          const eyeWhite = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
          eyeWhite.position.set(x, 1.2, 0.45);
          this.monkey.add(eyeWhite);
          const eye = new THREE.Mesh(eyeGeo, eyeMat);
          eye.position.set(x, 1.2, 0.55);
          this.monkey.add(eye);
        });

        // Ears
        const earGeo = new THREE.SphereGeometry(0.22, 8, 8);
        [-0.55, 0.55].forEach(x => {
          const ear = new THREE.Mesh(earGeo, bodyMat);
          ear.position.set(x, 1.15, 0);
          this.monkey.add(ear);
          const earInner = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), faceMat);
          earInner.position.set(x, 1.15, 0.05);
          this.monkey.add(earInner);
        });

        // Arms - these will animate
        this.arms = { left: this.createArm(), right: this.createArm() };
        this.arms.left.position.set(-0.6, 0.5, 0);
        this.arms.right.position.set(0.6, 0.5, 0);
        this.arms.right.scale.x = -1;
        this.monkey.add(this.arms.left);
        this.monkey.add(this.arms.right);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.6, 8);
        [-0.25, 0.25].forEach(x => {
          const leg = new THREE.Mesh(legGeo, bodyMat);
          leg.position.set(x, -0.7, 0);
          leg.rotation.x = 0.3;
          this.monkey.add(leg);
        });

        // Tail
        const tailPoints = [];
        for (let i = 0; i <= 10; i++) {
          const t = i / 10;
          tailPoints.push(new THREE.Vector3(
            0,
            -0.5 - t * 0.8,
            -0.4 - Math.sin(t * Math.PI) * 0.8
          ));
        }
        const tailCurve = new THREE.CatmullRomCurve3(tailPoints);
        const tailGeo = new THREE.TubeGeometry(tailCurve, 20, 0.08, 8, false);
        const tail = new THREE.Mesh(tailGeo, bodyMat);
        tail.castShadow = true;
        this.monkey.add(tail);

        this.scene.add(this.monkey);

        // Game state
        this.state = {
          phase: 'swinging', // 'swinging', 'flying', 'falling'
          currentVine: null,
          vineGrabPoint: new THREE.Vector3(),
          swingAngle: -Math.PI / 4, // Start angle
          swingVelocity: 0,
          velocity: new THREE.Vector3(),
          gravity: 35
        };
      }

      createArm() {
        const arm = new THREE.Group();

        // Upper arm
        const upperGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
        const armMat = new THREE.MeshLambertMaterial({ color: 0xd4712a });
        const upper = new THREE.Mesh(upperGeo, armMat);
        upper.position.y = -0.25;
        arm.add(upper);

        // Lower arm
        const lower = new THREE.Mesh(upperGeo, armMat);
        lower.position.y = -0.7;
        arm.add(lower);

        // Hand
        const handGeo = new THREE.SphereGeometry(0.14, 8, 8);
        const handMat = new THREE.MeshLambertMaterial({ color: 0xf4c99a });
        const hand = new THREE.Mesh(handGeo, handMat);
        hand.position.y = -0.95;
        arm.add(hand);

        return arm;
      }

      createVineSystem() {
        this.vines = [];
        this.bananaObjects = [];

        // Create initial vines with varied spacing
        let z = -5;
        for (let i = 0; i < 10; i++) {
          this.createVine(z);
          z -= 6 + Math.random() * 4; // 6-10 units apart
        }

        // Attach to first vine
        this.attachToVine(this.vines[0]);
      }

      createVine(z) {
        const vine = new THREE.Group();

        // Vine anchor point (at top) - way above screen
        const anchorY = 40;
        vine.userData = {
          anchorPoint: new THREE.Vector3(0, anchorY, z),
          grabbed: false,
          swingPhase: Math.random() * Math.PI * 2
        };

        // Main vine rope - much taller, extends off screen
        const vineHeight = 35;
        const ropeGeo = new THREE.CylinderGeometry(0.12, 0.08, vineHeight, 8);
        const ropeMat = new THREE.MeshLambertMaterial({ color: 0x2d5a1a });
        const rope = new THREE.Mesh(ropeGeo, ropeMat);
        rope.position.y = anchorY - vineHeight / 2;
        vine.add(rope);

        // Leaves along vine - more leaves for longer vine
        const leafGeo = new THREE.SphereGeometry(0.35, 6, 6);
        leafGeo.scale(1.2, 0.4, 0.6);
        const leafMat = new THREE.MeshLambertMaterial({ color: 0x3a8a30 });

        for (let i = 0; i < 12; i++) {
          const leaf = new THREE.Mesh(leafGeo, leafMat.clone());
          leaf.material.color.setHex(i % 2 === 0 ? 0x3a8a30 : 0x2d7a25);
          const yPos = anchorY - 4 - i * 2.5;
          leaf.position.set((i % 2 === 0 ? 0.4 : -0.4), yPos, 0);
          leaf.rotation.z = (i % 2 === 0 ? -0.6 : 0.6);
          vine.add(leaf);
        }

        // Grab point indicator - smaller, subtle glow
        const grabGeo = new THREE.SphereGeometry(0.25, 8, 8);
        const grabMat = new THREE.MeshBasicMaterial({
          color: 0x00ff88,
          transparent: true,
          opacity: 0.4
        });
        const grabPoint = new THREE.Mesh(grabGeo, grabMat);
        const grabY = 8; // Fixed grab height in playable area
        grabPoint.position.y = grabY;
        vine.add(grabPoint);
        vine.userData.grabIndicator = grabPoint;
        vine.userData.grabY = grabY;

        // Position vine with significant X variation for staggered layout
        // Alternate left/right with randomness for more interesting patterns
        const vineIndex = this.vines.length;
        const side = (vineIndex % 2 === 0) ? -1 : 1; // Alternate sides
        const baseOffset = side * (4 + Math.random() * 4); // 4-8 units left or right
        const xOffset = baseOffset + (Math.random() - 0.5) * 3; // Add some randomness
        vine.position.set(xOffset, 0, z);
        vine.userData.anchorPoint.x = xOffset;

        this.scene.add(vine);
        this.vines.push(vine);

        // Maybe add banana near this vine - at monkey's swinging level
        if (Math.random() > 0.3) {
          this.createBanana(xOffset + (Math.random() - 0.5) * 6, 5 + Math.random() * 3, z);
        }

        return vine;
      }

      createBanana(x, y, z) {
        const banana = new THREE.Group();

        // Brighter banana with emissive-like effect
        const bananaMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
        const bananaGeo = new THREE.TorusGeometry(0.35, 0.14, 8, 12, Math.PI * 0.8);

        for (let i = 0; i < 3; i++) {
          const b = new THREE.Mesh(bananaGeo, bananaMat);
          b.rotation.set(0, 0, Math.PI / 2 + (i - 1) * 0.25);
          b.position.x = (i - 1) * 0.14;
          banana.add(b);
        }

        // Inner glow (bright)
        const innerGlowGeo = new THREE.SphereGeometry(0.5, 8, 8);
        const innerGlowMat = new THREE.MeshBasicMaterial({
          color: 0xffff00,
          transparent: true,
          opacity: 0.5
        });
        banana.add(new THREE.Mesh(innerGlowGeo, innerGlowMat));

        // Outer glow (soft, larger)
        const outerGlowGeo = new THREE.SphereGeometry(1.0, 8, 8);
        const outerGlowMat = new THREE.MeshBasicMaterial({
          color: 0xffaa00,
          transparent: true,
          opacity: 0.25
        });
        banana.add(new THREE.Mesh(outerGlowGeo, outerGlowMat));

        // Point light to illuminate surroundings
        const bananaLight = new THREE.PointLight(0xffdd00, 0.5, 5);
        banana.add(bananaLight);

        banana.position.set(x, y, z);
        banana.userData = { collected: false, baseY: y };

        this.scene.add(banana);
        this.bananaObjects.push(banana);
      }

      setupControls() {
        const handleInput = (e) => {
          if (e.target.tagName === 'BUTTON') return;
          if (!this.isPlaying) return;
          this.jump();
        };

        document.addEventListener('click', handleInput);
        document.addEventListener('touchstart', (e) => {
          if (e.target.tagName === 'BUTTON') return;
          e.preventDefault();
          handleInput(e);
        }, { passive: false });

        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space') {
            e.preventDefault();
            if (this.isPlaying) {
              this.jump();
            } else if (!document.getElementById('start-screen').classList.contains('hidden')) {
              this.start();
            } else {
              this.restart();
            }
          }
        });
      }

      jump() {
        if (this.state.phase === 'falling') return;

        document.getElementById('touch-hint').classList.add('hidden');

        if (this.state.phase === 'swinging') {
          // Release from vine - calculate launch velocity based on swing
          const angle = this.state.swingAngle;
          const speed = Math.abs(this.state.swingVelocity) * 2;

          // Launch in direction of swing - more forgiving with stronger forward momentum
          const launchAngle = angle + Math.PI / 2; // Perpendicular to rope
          this.state.velocity.set(
            Math.cos(launchAngle) * speed * 0.5,
            Math.sin(launchAngle) * speed * 0.8 + 12, // More upward boost
            -18 - this.gameSpeed * 3 // More forward momentum
          );

          this.state.phase = 'flying';
          this.state.currentVine = null;

          // Arms forward while flying
          this.arms.left.rotation.x = -Math.PI / 2;
          this.arms.right.rotation.x = -Math.PI / 2;
        }
      }

      attachToVine(vine) {
        if (vine.userData.grabbed) return;

        vine.userData.grabbed = true;
        this.state.currentVine = vine;
        this.state.phase = 'swinging';

        // Set grab point
        this.state.vineGrabPoint.set(
          vine.position.x,
          vine.userData.grabY,
          vine.position.z
        );

        // Calculate initial swing angle based on approach
        const dx = this.monkey.position.x - this.state.vineGrabPoint.x;
        const dy = this.monkey.position.y - this.state.vineGrabPoint.y;
        this.state.swingAngle = Math.atan2(dx, -dy);

        // Initial swing velocity from momentum
        this.state.swingVelocity = this.state.velocity.x * 0.3;

        this.state.velocity.set(0, 0, 0);

        // Hide grab indicator
        vine.userData.grabIndicator.visible = false;

        // Arms up grabbing the vine!
        this.arms.left.rotation.x = Math.PI;
        this.arms.right.rotation.x = Math.PI;
        this.arms.left.rotation.z = 0.15;
        this.arms.right.rotation.z = -0.15;
      }

      tryGrabNearbyVine() {
        const pos = this.monkey.position;

        for (const vine of this.vines) {
          if (vine.userData.grabbed) continue;

          const grabPos = new THREE.Vector3(
            vine.position.x,
            vine.userData.grabY,
            vine.position.z
          );

          const dist = pos.distanceTo(grabPos);

          // Much more forgiving grab radius
          if (dist < 6) {
            this.attachToVine(vine);

            // Show feedback based on accuracy
            if (dist < 1.5) {
              this.showFeedback('PERFECT!', 'perfect');
            } else if (dist < 2.5) {
              this.showFeedback('GOOD!', 'good');
            }
            return true;
          }
        }
        return false;
      }

      showFeedback(text, type) {
        const el = document.getElementById('feedback');
        el.textContent = text;
        el.className = '';
        void el.offsetWidth;
        el.className = type;
      }


      collectBanana(banana) {
        if (banana.userData.collected) return;
        banana.userData.collected = true;
        this.bananas++;
        this.score = this.bananas; // Score IS bananas
        document.getElementById('score').textContent = this.score;

        // Animate collection
        const startPos = banana.position.clone();
        let t = 0;
        const animate = () => {
          t += 0.08;
          if (t >= 1) {
            this.scene.remove(banana);
            return;
          }
          banana.position.y = startPos.y + t * 4;
          banana.scale.setScalar(1 - t);
          banana.rotation.y += 0.2;
          requestAnimationFrame(animate);
        };
        animate();
      }

      update(dt) {
        if (!this.isPlaying) return;

        const state = this.state;
        this.gameSpeed = Math.min(1 + this.score / 3000, 2);

        if (state.phase === 'swinging' && state.currentVine) {
          // Pendulum physics
          const gravity = 15;
          const damping = 0.995;
          const swingRadius = 3; // How far monkey swings side to side

          // Angular acceleration from gravity
          const angularAccel = -(gravity / swingRadius) * Math.sin(state.swingAngle);
          state.swingVelocity += angularAccel * dt;
          state.swingVelocity *= damping;
          state.swingAngle += state.swingVelocity * dt;

          // Clamp swing angle - allow wider swings
          const maxAngle = Math.PI * 0.85;
          if (Math.abs(state.swingAngle) > maxAngle) {
            state.swingAngle = Math.sign(state.swingAngle) * maxAngle;
            state.swingVelocity *= -0.5;
          }

          // Position monkey directly on the vine, hands gripping it
          const vine = state.currentVine;
          const vineX = vine.position.x;
          const vineZ = vine.position.z;

          // Monkey swings side to side while holding the vine - wider swing
          const swingOffset = Math.sin(state.swingAngle) * 4;

          this.monkey.position.set(
            vineX + swingOffset,
            state.vineGrabPoint.y - 1.5, // Hands at grab point, body below
            vineZ + 0.8 // Slightly in front of vine
          );

          // Rotate monkey to match swing - more dramatic rotation
          this.monkey.rotation.z = state.swingAngle * 0.7;
          this.monkey.rotation.x = 0;

        } else if (state.phase === 'flying' || state.phase === 'falling') {
          // Apply gravity
          state.velocity.y -= state.gravity * dt;

          // Move monkey
          this.monkey.position.add(state.velocity.clone().multiplyScalar(dt));

          // Rotate based on velocity
          this.monkey.rotation.z = Math.sin(Date.now() * 0.01) * 0.3;
          this.monkey.rotation.x = -state.velocity.y * 0.02;

          // Try to grab vine - always check when flying (not just when falling)
          if (state.phase === 'flying') {
            // Magnet effect - gently pull toward nearby vines
            for (const vine of this.vines) {
              if (vine.userData.grabbed) continue;
              const grabPos = new THREE.Vector3(vine.position.x, vine.userData.grabY, vine.position.z);
              const dist = this.monkey.position.distanceTo(grabPos);
              if (dist < 8 && dist > 1) {
                // Pull toward vine
                const pullStrength = 0.15 * (1 - dist / 8);
                const dir = grabPos.clone().sub(this.monkey.position).normalize();
                state.velocity.x += dir.x * pullStrength;
                state.velocity.y += dir.y * pullStrength * 0.5;
              }
            }
            this.tryGrabNearbyVine();
          }

          // Check if fallen too far
          if (this.monkey.position.y < -5) {
            state.phase = 'falling';
            if (this.monkey.position.y < -15) {
              this.gameOver();
              return;
            }
          }
        }

        // Update monkey light
        this.monkeyLight.position.copy(this.monkey.position);
        this.monkeyLight.position.y += 3;

        // Camera follow
        const targetZ = this.monkey.position.z + 22;
        const targetX = this.monkey.position.x * 0.4;
        const targetY = Math.max(this.monkey.position.y + 5, 8);

        this.camera.position.x += (targetX - this.camera.position.x) * 0.08;
        this.camera.position.y += (targetY - this.camera.position.y) * 0.05;
        this.camera.position.z += (targetZ - this.camera.position.z) * 0.08;

        this.camera.lookAt(
          this.monkey.position.x * 0.5,
          this.monkey.position.y + 2,
          this.monkey.position.z - 10
        );

        // Update vines - sway ungrabbed ones
        this.vines.forEach(vine => {
          if (!vine.userData.grabbed) {
            vine.rotation.z = Math.sin(Date.now() * 0.001 + vine.userData.swingPhase) * 0.08;
            vine.userData.grabIndicator.visible = true;

            // Pulse grab indicator
            const scale = 1 + Math.sin(Date.now() * 0.005) * 0.2;
            vine.userData.grabIndicator.scale.setScalar(scale);
          }

          // Remove vines far behind
          if (vine.position.z > this.monkey.position.z + 30) {
            this.scene.remove(vine);
            this.vines = this.vines.filter(v => v !== vine);
          }
        });

        // Spawn new vines ahead with varied spacing
        const furthestZ = Math.min(...this.vines.map(v => v.position.z));
        if (this.monkey.position.z - furthestZ < 50) {
          const spacing = 6 + Math.random() * 4; // 6-10 units apart
          this.createVine(furthestZ - spacing);
        }

        // Update bananas
        this.bananaObjects.forEach((banana, i) => {
          if (banana.userData.collected) return;

          banana.rotation.y += 0.02;
          banana.position.y = banana.userData.baseY + Math.sin(Date.now() * 0.003 + i) * 0.3;

          // Check collection
          if (this.monkey.position.distanceTo(banana.position) < 1.8) {
            this.collectBanana(banana);
          }

          // Remove if behind
          if (banana.position.z > this.monkey.position.z + 20) {
            this.scene.remove(banana);
            this.bananaObjects = this.bananaObjects.filter(b => b !== banana);
          }
        });

        // Update fireflies (particles)
        const time = Date.now() * 0.001;
        this.particles.forEach(p => {
          p.position.y = p.userData.baseY + Math.sin(time * p.userData.speed + p.userData.offset) * 1.5;
          p.position.x = p.userData.baseX + Math.sin(time * p.userData.speed * 0.7 + p.userData.offset) * 2;
          // Blinking glow
          const glow = p.children[0];
          if (glow) {
            glow.material.opacity = 0.2 + Math.sin(time * p.userData.glowSpeed) * 0.3;
          }
          p.material.opacity = 0.6 + Math.sin(time * p.userData.glowSpeed) * 0.4;
        });

        // Update butterflies
        if (this.butterflies) {
          this.butterflies.forEach(b => {
            // Fluttering movement
            b.position.x = b.userData.basePos.x + Math.sin(time * b.userData.speed + b.userData.offset) * 3;
            b.position.y = b.userData.basePos.y + Math.sin(time * b.userData.speed * 1.5 + b.userData.offset) * 1.5;
            b.position.z = b.userData.basePos.z + Math.cos(time * b.userData.speed * 0.5 + b.userData.offset) * 2;
            // Wing flapping
            b.userData.leftWing.rotation.y = 0.3 + Math.sin(time * b.userData.wingSpeed) * 0.7;
            b.userData.rightWing.rotation.y = -0.3 - Math.sin(time * b.userData.wingSpeed) * 0.7;
            // Face direction of movement
            b.rotation.y = Math.sin(time * b.userData.speed + b.userData.offset) * 0.5;
          });
        }

        // Recycle trees
        this.trees.forEach(tree => {
          if (tree.position.z > this.monkey.position.z + 40) {
            tree.position.z -= 150;
            tree.position.x = (Math.random() > 0.5 ? 1 : -1) * (10 + Math.random() * 25);
          }
        });

        // Recycle canopy elements
        if (this.canopy) {
          this.canopy.forEach(leaf => {
            if (leaf.position.z > this.monkey.position.z + 50) {
              leaf.position.z -= 150;
              leaf.position.x = (Math.random() - 0.5) * 80;
            }
            // Gentle swaying
            leaf.rotation.z = Math.sin(time * 0.5 + leaf.position.x * 0.1) * 0.1;
          });
        }

        // Recycle ground details
        if (this.groundDetails) {
          this.groundDetails.forEach(detail => {
            if (detail.position.z > this.monkey.position.z + 50) {
              detail.position.z -= 150;
            }
          });
        }

        // Move butterflies with player roughly
        if (this.butterflies) {
          this.butterflies.forEach(b => {
            if (b.userData.basePos.z > this.monkey.position.z + 30) {
              b.userData.basePos.z -= 80;
              b.userData.basePos.x = (Math.random() - 0.5) * 30;
            }
          });
        }

        // Move fireflies with player roughly
        this.particles.forEach(p => {
          if (p.userData.baseY && p.position.z > this.monkey.position.z + 40) {
            p.position.z -= 80;
            p.userData.baseX = (Math.random() - 0.5) * 40;
          }
        });
      }

      gameOver() {
        this.isPlaying = false;

        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('swingerMonkeyHighScore', this.highScore);
        }

        document.getElementById('final-score').textContent = this.score;
        document.getElementById('high-score').textContent = `BEST: ${this.highScore}`;
        document.getElementById('game-over').classList.add('show');

        this.showFeedback('OOPS!', 'miss');
      }

      start() {
        document.getElementById('start-screen').classList.add('hidden');
        this.isPlaying = true;
        this.score = 0;
        this.bananas = 0;
        this.gameSpeed = 1;

        document.getElementById('score').textContent = '0';
      }

      restart() {
        document.getElementById('game-over').classList.remove('show');

        // Reset monkey
        this.monkey.position.set(0, 10, 0);
        this.monkey.rotation.set(0, 0, 0);

        // Clear vines
        this.vines.forEach(v => this.scene.remove(v));
        this.vines = [];
        this.bananaObjects.forEach(b => this.scene.remove(b));
        this.bananaObjects = [];

        // Recreate vines with varied spacing
        let z = -5;
        for (let i = 0; i < 10; i++) {
          this.createVine(z);
          z -= 6 + Math.random() * 4;
        }

        // Reset state
        this.state = {
          phase: 'swinging',
          currentVine: null,
          vineGrabPoint: new THREE.Vector3(),
          swingAngle: -Math.PI / 4,
          swingVelocity: 0,
          velocity: new THREE.Vector3(),
          gravity: 35
        };

        this.attachToVine(this.vines[0]);

        // Reset camera
        this.camera.position.set(0, 8, 25);

        this.score = 0;
        this.bananas = 0;
        this.gameSpeed = 1;

        document.getElementById('score').textContent = '0';
        document.getElementById('touch-hint').classList.remove('hidden');

        this.isPlaying = true;
      }

      animate() {
        let lastTime = performance.now();

        const loop = (now) => {
          requestAnimationFrame(loop);

          const dt = Math.min((now - lastTime) / 1000, 0.05);
          lastTime = now;

          this.update(dt);
          this.renderer.render(this.scene, this.camera);
        };

        requestAnimationFrame(loop);
      }
    }

    const game = new JungleSwing();
  </script>
</body>
</html>
